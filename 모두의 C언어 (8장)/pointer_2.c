/*포인터를 사용하는 이유에 대해서 공부해보자.*/
/*일반적으로 지역변수를 이용하면 main 함수의 값에 영향을 끼치지 못한다. 그러나 포인터를 이용하면 main 함수의 값에 접근할 수 있다.*/
/*이것이 가능한 이유는 포인터를 통해서 call by reference가 되기 때문이다.*/

//#include <stdio.h>
//
//int change(int* x, int* y);
//
//int main()
//{
//	int a = 1, b = 2;
//
//	change(&a, &b); // 주소값을 통해서 역참조하기 때문에 a의 값과 b의 값이 변한다.
//
//	printf("a의 값은 %d이고, b의 값은 %d이다.", a, b);
//
//	return 0;
//}
//
//int change(int* x, int* y) {
//	int temp = 0;
//
//	temp = *x;
//	*x = *y;
//	*y = temp;
//}

/*배열의 이름과 배열의 첫번째 요소를 가리키는 포인터 주소는 같다.*/

//#include <stdio.h>
//
//int main()
//{
//	int a[5] = { 0, 1, 2, 3, 4 };
//
//	for (int i = 0; i < 5; i++) {
//		printf("a[%d]의 주소는 %d이다.\n", i, &a[i]);
//	}
//	printf("a의 이름은 %d이다.", a); // 결과에서 보다시피 배열의 첫번째 요소의 주소와 같다.
//	return 0;
//}

/*이에 따라 포인터를 이용하여 배열의 값을 변경하는 것도 가능하다.*/

//#include <stdio.h>
//
//int main()
//{
//	int a[5] = { 1, 2, 3, 4, 5 };
//	int* b;
//	
//	b = a;
//
//	for (int i = 0; i < 5; i++) {
//		printf("a[%d]의 주소는 %d\n", i, &a[i]);
//		printf("포인터 b+%d의 값은 %d\n", i, b + i); // 포인터에 값을 더하는 것은 주소 단위로 증가하는 것을 의미한다. 1 * 4
//		/*문자열의 경우에는 주소값이 4바이트가 아니라 1바이트씩 증가한다.*/
//	}
//	return 0;
//}